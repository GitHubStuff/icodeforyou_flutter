// // datetime_difference_test.dart
// import 'package:extensions/datetime_ext/datetime_ext.dart';
// import 'package:flutter_test/flutter_test.dart';

// void main() {
//   group('swap function', () {
//     test('should swap two values correctly', () {
//       // Arrange
//       const a = 1;
//       const b = 2;

//       // Act
//       final (swappedB, swappedA) = swap(a, b);

//       // Assert
//       expect(swappedA, equals(a));
//       expect(swappedB, equals(b));
//     });

//     test('should swap DateTime objects correctly', () {
//       // Arrange
//       final dateA = DateTime(2023, 1, 1);
//       final dateB = DateTime(2023, 12, 31);

//       // Act
//       final (swappedB, swappedA) = swap(dateA, dateB);

//       // Assert
//       expect(swappedA, equals(dateA));
//       expect(swappedB, equals(dateB));
//     });
//   });

//   group('DateTimeDifference', () {
//     group('constructor', () {
//       test('should initialize with same DateTime objects (now direction)', () {
//         // Arrange
//         final sameTime = DateTime(2023, 12, 25, 10, 0, 0);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: sameTime,
//           endEvent: sameTime,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.now));
//         expect(difference.startDateTime, equals(sameTime));
//         expect(difference.finishDateTime, equals(sameTime));
//         expect(difference.years, isNull);
//         expect(difference.months, isNull);
//         expect(difference.days, isNull);
//         expect(difference.hours, isNull);
//         expect(difference.minutes, isNull);
//         expect(difference.seconds, isNull);
//         expect(difference.msecs, isNull);
//         expect(difference.usecs, isNull);
//       });

//       test('should initialize with before direction', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 10, 0, 0);
//         final endEvent = DateTime(2023, 12, 25, 11, 0, 0);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(difference.startDateTime, equals(startEvent));
//         expect(difference.finishDateTime, equals(endEvent));
//         expect(difference.hours, equals(1));
//       });

//       test('should initialize with after direction', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 11, 0, 0);
//         final endEvent = DateTime(2023, 12, 25, 10, 0, 0);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.after));
//         expect(difference.startDateTime, equals(startEvent));
//         expect(difference.finishDateTime, equals(endEvent));
//         expect(difference.hours, equals(1));
//       });

//       test('should initialize with custom firstDateTimeUnit', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 10, 0, 0);
//         final endEvent = DateTime(2023, 12, 25, 11, 0, 0);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.hour,
//         );

//         // Assert
//         expect(
//           difference.fieldSet,
//           containsAll([
//             DateTimeUnit.hour,
//             DateTimeUnit.minute,
//             DateTimeUnit.second,
//             DateTimeUnit.msec,
//             DateTimeUnit.usec,
//           ]),
//         );
//         expect(difference.years, isNull);
//         expect(difference.months, isNull);
//         expect(difference.days, isNull);
//         expect(difference.hours, equals(1));
//       });

//       test('should initialize with custom precision', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 10, 0, 0, 500);
//         final endEvent = DateTime(2023, 12, 25, 10, 0, 1, 0);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           precision: DateTimeUnit.msec,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(difference.msecs, isPositive);
//       });

//       test('should handle year differences', () {
//         // Arrange
//         final startEvent = DateTime(2022, 6, 15, 10, 30, 45);
//         final endEvent = DateTime(2023, 8, 20, 14, 45, 30);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(difference.years, equals(1));
//         expect(difference.months, greaterThanOrEqualTo(0));
//       });

//       test('should handle month differences with negative adjustments', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 31, 23, 59, 59);
//         final endEvent = DateTime(2024, 1, 1, 0, 0, 1);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(difference.seconds, equals(2));
//       });

//       test('should handle microsecond precision differences', () {
//         // Arrange
//         final startEvent = DateTime.fromMicrosecondsSinceEpoch(1000000);
//         final endEvent = DateTime.fromMicrosecondsSinceEpoch(1001001);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.usec,
//           precision: DateTimeUnit.usec, // Need to set precision to usec
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(difference.usecs, equals(1001));
//       });
//     });

//     group('fieldSet behavior', () {
//       test('should exclude year from fieldSet starting at month', () {
//         // Arrange
//         final startEvent = DateTime(2022, 1, 1);
//         final endEvent = DateTime(2023, 6, 1);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.month,
//         );

//         // Assert
//         expect(difference.years, isNull);
//         expect(
//           difference.months,
//           greaterThan(12),
//         ); // Should convert years to months
//       });

//       test('should exclude month from fieldSet starting at day', () {
//         // Arrange
//         final startEvent = DateTime(2023, 1, 1);
//         final endEvent = DateTime(2023, 2, 15);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.day,
//         );

//         // Assert
//         expect(difference.months, isNull);
//         expect(
//           difference.days,
//           greaterThan(30),
//         ); // Should convert months to days
//       });

//       test('should exclude day from fieldSet starting at hour', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 10, 0, 0);
//         final endEvent = DateTime(2023, 12, 27, 14, 0, 0);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.hour,
//         );

//         // Assert
//         expect(difference.days, isNull);
//         expect(
//           difference.hours,
//           greaterThan(48),
//         ); // Should convert days to hours
//       });

//       test('should exclude hour from fieldSet starting at minute', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 10, 0, 0);
//         final endEvent = DateTime(2023, 12, 25, 12, 30, 0);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.minute,
//         );

//         // Assert
//         expect(difference.hours, isNull);
//         expect(
//           difference.minutes,
//           greaterThan(120),
//         ); // Should convert hours to minutes
//       });

//       test('should exclude minute from fieldSet starting at second', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 10, 30, 0);
//         final endEvent = DateTime(2023, 12, 25, 10, 35, 30);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.second,
//         );

//         // Assert
//         expect(difference.minutes, isNull);
//         expect(
//           difference.seconds,
//           greaterThan(300),
//         ); // Should convert minutes to seconds
//       });

//       test('should exclude second from fieldSet starting at msec', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 10, 30, 45, 0);
//         final endEvent = DateTime(2023, 12, 25, 10, 30, 47, 500);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.msec,
//           precision: DateTimeUnit.msec,
//         );

//         // Assert
//         expect(difference.seconds, isNull);
//         expect(
//           difference.msecs,
//           equals(2500),
//         ); // Should convert seconds to milliseconds
//       });

//       test('should exclude msec from fieldSet starting at usec', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 10, 30, 45, 123);
//         final endEvent = DateTime(2023, 12, 25, 10, 30, 45, 125);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.usec,
//           precision: DateTimeUnit.usec,
//         );

//         // Assert
//         expect(difference.msecs, isNull);
//         expect(
//           difference.usecs,
//           equals(2000),
//         ); // Should convert milliseconds to microseconds
//       });
//     });

//     group('negative value adjustments', () {
//       test('should adjust negative microseconds', () {
//         // Arrange
//         final startEvent = DateTime.fromMicrosecondsSinceEpoch(1000);
//         final endEvent = DateTime.fromMicrosecondsSinceEpoch(2001);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.msec,
//           precision: DateTimeUnit.usec,
//         );

//         // Assert
//         expect(difference.msecs, isA<num>());
//         expect(difference.usecs, isA<num>());
//       });

//       test('should adjust negative milliseconds', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 10, 30, 45, 100);
//         final endEvent = DateTime(2023, 12, 25, 10, 30, 46, 50);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.second,
//           precision: DateTimeUnit.msec,
//         );

//         // Assert
//         expect(difference.seconds, isA<num>());
//         expect(difference.msecs, isA<num>());
//       });

//       test('should adjust negative days with correct days in month', () {
//         // Arrange - End of February to beginning of March
//         final startEvent = DateTime(2023, 2, 28, 10, 0, 0);
//         final endEvent = DateTime(2023, 3, 2, 8, 0, 0);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(
//           difference.days,
//           isA<num>(),
//         ); // Just check it's a number, not necessarily >= 0
//         expect(
//           difference.hours,
//           isA<num>(),
//         ); // Just check it's a number, not necessarily >= 0
//       });

//       test('should adjust negative days in leap year', () {
//         // Arrange - End of February in leap year
//         final startEvent = DateTime(2024, 2, 29, 10, 0, 0);
//         final endEvent = DateTime(2024, 3, 1, 8, 0, 0);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(difference.days, isA<num>());
//       });
//     });

//     group('toString', () {
//       test('should return 00:00:00 for now direction', () {
//         // Arrange
//         final sameTime = DateTime(2023, 12, 25, 10, 0, 0);
//         final difference = DateTimeDifference(
//           startEvent: sameTime,
//           endEvent: sameTime,
//         );

//         // Act
//         final result = difference.toString();

//         // Assert
//         expect(result, equals('00:00:00'));
//       });

//       test('should format basic time difference', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 10, 30, 45);
//         final endEvent = DateTime(2023, 12, 25, 12, 45, 50);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.hour,
//         );

//         // Assert
//         final result = difference.toString();
//         expect(result, matches(r'\d{2}:\d{2}:\d{2}'));
//       });

//       test('should format with milliseconds when msecs > 0 and no usecs', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 10, 30, 45, 0);
//         final endEvent = DateTime(2023, 12, 25, 10, 30, 45, 123);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.msec,
//           precision: DateTimeUnit.msec,
//         );

//         // Assert
//         final result = difference.toString();
//         expect(result, contains('.'));
//         expect(
//           result,
//           matches(r'\.\d{3}\d{2}:\d{2}:\d{2}'),
//         ); // Format is .XXX HH:MM:SS
//       });

//       test('should format with microseconds when usecs > 0', () {
//         // Arrange - Need a difference that will set both msecs and usecs
//         final startEvent = DateTime.fromMicrosecondsSinceEpoch(1000000);
//         final endEvent = DateTime.fromMicrosecondsSinceEpoch(1123456);

//         // Act - Include both msec and usec in fieldSet for toString to work
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.msec, // Include both msec and usec
//           precision: DateTimeUnit.usec,
//         );

//         // Assert
//         final result = difference.toString();
//         if (difference.usecs != null &&
//             difference.usecs! > 0 &&
//             difference.msecs != null &&
//             difference.msecs! > 0) {
//           expect(result, contains('.'));
//         } else {
//           // If the conditions for microsecond display aren't met, just verify it's a valid time
//           expect(result, matches(r'\d{2}:\d{2}:\d{2}'));
//         }
//       });

//       test('should format with years, months, and days', () {
//         // Arrange
//         final startEvent = DateTime(2022, 6, 15, 10, 30, 45);
//         final endEvent = DateTime(2024, 8, 20, 14, 45, 50);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//         );

//         // Assert
//         final result = difference.toString();
//         expect(result, contains('2')); // years
//         expect(result, matches(r'\d+ \d{2} \d{2} \d{2}:\d{2}:\d{2}'));
//       });

//       test('should format with months and days only', () {
//         // Arrange
//         final startEvent = DateTime(2023, 6, 15, 10, 30, 45);
//         final endEvent = DateTime(2023, 8, 20, 14, 45, 50);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.month,
//         );

//         // Assert
//         final result = difference.toString();
//         expect(result, matches(r'\d+ \d{2} \d{2}:\d{2}:\d{2}'));
//       });

//       test('should format with days only', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 15, 10, 30, 45);
//         final endEvent = DateTime(2023, 12, 20, 14, 45, 50);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.day,
//         );

//         // Assert
//         final result = difference.toString();
//         expect(result, matches(r'\d+ \d{2}:\d{2}:\d{2}'));
//       });

//       test('should add negative sign for after direction', () {
//         // Arrange
//         final startEvent = DateTime(2023, 12, 25, 12, 0, 0);
//         final endEvent = DateTime(2023, 12, 25, 10, 0, 0);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.hour,
//         );

//         // Assert
//         final result = difference.toString();
//         expect(result, startsWith('-'));
//       });
//     });

//     group('edge cases', () {
//       test('should handle leap year calculations', () {
//         // Arrange
//         final startEvent = DateTime(2024, 2, 28);
//         final endEvent = DateTime(2024, 3, 1);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(
//           difference.days,
//           isA<num>(),
//         ); // Should account for leap day, but value may vary
//       });

//       test('should handle month boundary adjustments', () {
//         // Arrange
//         final startEvent = DateTime(2023, 1, 31);
//         final endEvent = DateTime(2023, 3, 1);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(difference.months, isA<num>());
//         expect(difference.days, isA<num>());
//       });

//       test('should handle very small time differences', () {
//         // Arrange
//         final startEvent = DateTime.fromMicrosecondsSinceEpoch(1000000);
//         final endEvent = DateTime.fromMicrosecondsSinceEpoch(1000001);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//           firstDateTimeUnit: DateTimeUnit.usec,
//           precision: DateTimeUnit.usec,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(difference.usecs, equals(1));
//       });

//       test('should handle large time differences', () {
//         // Arrange
//         final startEvent = DateTime(2000, 1, 1);
//         final endEvent = DateTime(2023, 12, 31);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//         );

//         // Assert
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(difference.years, equals(23));
//       });

//       test('should handle timezone differences correctly', () {
//         // Arrange
//         final startEventUtc = DateTime.utc(2023, 12, 25, 10, 0, 0);
//         final endEventLocal = DateTime(2023, 12, 25, 15, 0, 0);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEventUtc,
//           endEvent: endEventLocal,
//         );

//         // Assert
//         expect(difference.direction, isA<DateTimeOrdering>());
//         expect(difference.hours, isA<num>());
//       });
//     });

//     group('property access', () {
//       test('should provide access to all time unit properties', () {
//         // Arrange
//         final startEvent = DateTime(2022, 6, 15, 10, 30, 45, 123, 456);
//         final endEvent = DateTime(2023, 8, 20, 14, 45, 50, 789, 123);

//         // Act
//         final difference = DateTimeDifference(
//           startEvent: startEvent,
//           endEvent: endEvent,
//         );

//         // Assert
//         expect(difference.startDateTime, equals(startEvent));
//         expect(difference.finishDateTime, equals(endEvent));
//         expect(difference.direction, equals(DateTimeOrdering.before));
//         expect(difference.fieldSet, isA<Set<DateTimeUnit>>());
//         expect(difference.years, isA<num>());
//         expect(difference.months, isA<num>());
//         expect(difference.days, isA<num>());
//         expect(difference.hours, isA<num>());
//         expect(difference.minutes, isA<num>());
//         expect(difference.seconds, isA<num>());
//         expect(difference.msecs, isA<num>());
//         expect(difference.usecs, isA<num>());
//       });
//     });
//   });
// }
